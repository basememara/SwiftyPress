{
    "posts": [
        {
            "id": 20633,
            "title": "Swifty Localization with Xcode Support",
            "slug": "swifty-localization-xcode-support",
            "type": "post",
            "excerpt": "Localization in Xcode is handled with NSLocalizedString, but it is such a verbose and legacy-like API. There's a Swiftier way that still respects Xcode .xliff exports and comments.",
            "created": "2017-07-11T19:00:59",
            "modified": "2019-01-17T14:48:00",
            "comment_count": 4,
            "link": "https://basememara.com/swifty-localization-xcode-support/",
            "author": 2,
            "featured_media": 20745,
            "categories": [
                55
            ],
            "tags": [
                77,
                50,
                47
            ],
            "content": "<p>Localization can be as much fun as unit testing. And like unit testing, it <em>can</em> be fun if it makes your code more robust and flexible (dependency injection and encapsulation anyone?). For example, once you internationalize your app and start viewing it in right-to-left languages, you&#8217;ll notice areas you&#8217;ve been using auto-layout wrong and start better habits such as using <em>UIStackViews</em> over <em>UILabel</em> text-alignments or tweaking hugging and resistance priorities. There&#8217;s one nagging thing that keeps coming up with localization though&#8230;</p>\n<h2><span>NSLocalizedString</span></h2>\n<p>Our old friend, `NSLocalizedString(&#8220;some.dialog.message&#8221;, comment: &#8220;My main dialog message for tutorial&#8221;)`. These localization API&#8217;s can be really bloated and ugly.. it can get out of control. Take this for example:</p>\n<pre class=\"lang:swift decode:true\">let title = NSLocalizedString(\"tutorial.alert.title\", comment: \"Title of main tutorial dialog\")\r\nlet message: String = .localizedStringWithFormat(NSLocalizedString(\"one.corner.label.1\", comment: \"First corner of main screen inserting number\"), 9876)</pre>\n<p>There&#8217;s so many un-Swifty things about this; there&#8217;s the &#8220;NS-&#8221; prefix, some irrelevant comments in the code, `localizedStringWithFormat` hasn&#8217;t been split up to function parameters, formatting with locale is some nested call.. I don&#8217;t think it can get any worse.</p>\n<p><img src=\"http://basememara.com/wp-content/uploads/2017/07/NSLocalizedString_Napoleon_Meme-500x350.jpg\" alt=\"\" width=\"400\" height=\"280\" class=\"aligncenter wp-image-20648\" /></p>\n<h2>Getting Swifty With It</h2>\n<p>One common technique in making `NSLocalizedString` more Swifty is wrapping it up in a¬†<code>String</code>¬†extension:</p>\n<pre class=\"lang:swift decode:true\">extension String {\r\n    \r\n    var localized: String {\r\n        return NSLocalizedString(self, comment: \"\")\r\n    }\r\n    \r\n    func localized(comment: String) -&gt; String {\r\n        return NSLocalizedString(self, comment: comment)\r\n    }\r\n}\r\n\r\nprint(\"some.dialog.message\".localized)</pre>\n<p>Looks good, although it still doesn&#8217;t solve comments from being infused in your code. Furthermore, there&#8217;s one big deal-breaker with this: Xcode will not export the localization to a <em>.xliff</em> file since¬†<em>NSLocalizedString</em> is being¬†used dynamically at runtime here.</p>\n<p>Xcode&#8217;s localization export depends on the hardcoded macro `NSLocalizedString` to do the search for export, so we still have to use them. Yes,¬†<em>NSLocalizedString</em> is a macro! Hopefully the localization export feature can be rebuilt on top of Xcode 9+&#8217;s refactoring engine üòâ</p>\n<h2>Now with Xcode Support‚Ñ¢</h2>\n<p>Let&#8217;s take our last attempt further to get the right API while respecting ¬†Xcode support. Using <code>Enums</code>¬†to handle this would be sweet, but you have to use literals so this won&#8217;t compile:</p>\n<pre class=\"lang:swift decode:true\">enum Localizable: String {\r\n    //Compile error: Raw value for enum case must be a literal\r\n    case tutorialAlert = NSLocalizedString(\"tutorial.alert.title\", comment: \"Some comment\")\r\n}</pre>\n<p>That&#8217;s fine; actually extending a <code>struct</code>¬†would work out better because then I can use extensions to add more localized strings instead of using cases. Let&#8217;s adjust:</p>\n<pre class=\"lang:swift decode:true\">struct Localizable {\r\n    private init() { }\r\n}\r\n\r\nextension Localizable {\r\n    static let title = NSLocalizedString(\"tutorial.alert.title\", comment: \"Title of main tutorial dialog\")\r\n    static let message = NSLocalizedString(\"one.corner.label.1\", comment: \"First corner of main screen inserting number\")\r\n}\r\n\r\n// ViewController.swift\r\nlet title = Localizable.title\r\nlet message: String = .localizedStringWithFormat(Localizable.message, 9876)</pre>\n<p>Still needs a bit more work.</p>\n<p><img src=\"http://basememara.com/wp-content/uploads/2017/07/NSLocalizedString_Office_Space_Meme-500x418.jpg\" alt=\"\" width=\"400\" height=\"335\" class=\"aligncenter wp-image-20652\" srcset=\"https://basememara.com/wp-content/uploads/2017/07/NSLocalizedString_Office_Space_Meme-500x418.jpg 500w, https://basememara.com/wp-content/uploads/2017/07/NSLocalizedString_Office_Space_Meme.jpg 526w\" sizes=\"(max-width: 400px) 100vw, 400px\" /></p>\n<h2>Localization Micro-Library</h2>\n<p>When refactoring Swift code, one question I ask is how I can leverage inference. I&#8217;d like to end up with something like this:</p>\n<pre class=\"lang:swift decode:true\">let title: String = .title\r\nlet message: String = .localizedStringWithFormat(.message, 9876)</pre>\n<p>To achieve this, we&#8217;d have to move all the¬†extensions to <code>String</code>, which would be obnoxious and pollute our <code>String</code>¬†API. Instead, we&#8217;ll have to extend the `Localizable` struct along with¬†<code>String</code>:</p>\n<pre class=\"lang:swift decode:true\">extension String {\r\n    \r\n    static func localized(_ key: Localizable) -&gt; String {\r\n        return key.contents\r\n    }\r\n}\r\n\r\nstruct Localizable {\r\n    fileprivate let contents: String\r\n    \r\n    init(_ contents: String) {\r\n        self.contents = contents\r\n    }\r\n}\r\n\r\nextension Localizable {\r\n    static let title = Localizable(NSLocalizedString(\"tutorial.dialog.title\", comment: \"Title of main tutorial dialog\"))\r\n    static let message = Localizable(NSLocalizedString(\"tutorial.dialog.message\", comment: \"First corner of main screen inserting number\"))\r\n}</pre>\n<p>Notice how we adjusted the <code>Localizable</code> static properties to return itself for later inference by storing the localized string within its initializer.¬†Now we can do this:</p>\n<pre class=\"lang:swift decode:true\">let title: String = .localized(.title)</pre>\n<p>It&#8217;s not as slim as I aimed (which was too terse?), but it&#8217;s reasonable. And still reasonable even though you have to manage the¬†<code>NSLocalizedString</code>¬†list through¬†<code>Localizable</code>¬†static properties, but there&#8217;s no way around that &#8211; at least now they&#8217;re consolidated and reusable from one place, also making comment management easier.</p>\n<h2>Now with Locale Support‚Ñ¢</h2>\n<p>For extending <code>.localizedStringWithFormat</code>, there‚Äôs still some work to do.¬†Below will give *empty memory values* at runtime, even though it *dangerously compiles*:</p>\n<pre class=\"lang:swift decode:true \">extension String { // WRONG: Don't do this!\r\n\r\n    static func localizedFormat(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return String(format: key.contents, arguments)\r\n    }\r\n    \r\n    static func localizedLocale(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return .localizedStringWithFormat(key.contents, arguments)\r\n    }\r\n}</pre>\n<p>There are nuances we have to deal with when passing variable arguments to other functions since `CVarArg` is a bridge to low-level¬†<em>C-language</em>¬†API&#8217;s. We have to facilitate passing the `CVarArg` arguments to other functions via pointers using Swift&#8217;s¬†<em>&#8220;<a href=\"https://developer.apple.com/documentation/swift/2294740-withvalist\" target=\"_blank\" rel=\"noopener\">withVaList</a>&#8220;</em>:</p>\n<pre class=\"lang:swift decode:true\">extension String {\r\n    \r\n    /// A string initialized by using format as a template into which values in argList are substituted according the current locale information.\r\n    private static var vaListHandler: (_ key: String, _ arguments: CVaListPointer, _ locale: Locale?) -&gt; String {\r\n        // https://stackoverflow.com/questions/42428504/swift-3-issue-with-cvararg-being-passed-multiple-times\r\n        return { return NSString(format: $0, locale: $2, arguments: $1) as String }\r\n    }\r\n\r\n    /// Returns a string created by using a given format string as a template into which the remaining argument values are substituted.\r\n    /// Equivalent to `String(format: value)`.\r\n    static func localizedFormat(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return withVaList(arguments) { vaListHandler(key.contents, $0, nil) } as String\r\n    }\r\n\r\n    /// Returns a string created by using a given format string as a template into which the\r\n    /// remaining argument values are substituted according to the user‚Äôs default locale.\r\n    /// Equivalent to `String.localizedStringWithFormat(value, arguments)`.\r\n    static func localizedLocale(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return withVaList(arguments) { vaListHandler(key.contents, $0, .current) } as String\r\n    }\r\n}</pre>\n<p>Now it works and we end up with this:</p>\n<pre class=\"lang:swift decode:true\">// Before\r\nlet title = NSLocalizedString(\"tutorial.alert.title\", comment: \"Title of main tutorial dialog\")\r\nlet message: String = .localizedStringWithFormat(NSLocalizedString(\"one.corner.label.1\", comment: \"First corner of main screen inserting number\"), 9876)\r\nlet caption = String(format: NSLocalizedString(\"current.app.name.version\", comment: \"Center display of app name and current version\"), \"v1.1\")\r\n\r\n// After\r\nlet title: String = .localized(.tutorialAlertTitle)\r\nlet message: String = .localizedLocale(.oneCornerLabel1, 9876)\r\nlet caption: String = .localizedFormat(.currentAppNameVersion, \"v1.1\")</pre>\n<p>And Xcode&#8217;s localization export to <em>.xliff</em> works perfectly and with comments since <code>NSLocalizedString</code>¬†is spelled out in the <code>Localizable</code>¬†static extensions¬†<a href=\"https://emojipedia.org/thumbs-up-sign/\" onmousedown=\"return rwt(this,'','','','7','AFQjCNHgpXSOoYKJfqGfOwBIm6b3V91rQQ','','0ahUKEwjAmZ2Dr_zUAhVJfiYKHQdvCykQFgg5MAY','','',event)\">üëç</a></p>\n<h2>The Full Example</h2>\n<p>Below is how the result would look like in an app..</p>\n<p><em>Before:</em></p>\n<pre class=\"lang:swift decode:true \">class ViewController1: UIViewController {\r\n    \r\n    ...\r\n    \r\n    override func viewDidLoad() {\r\n        super.viewDidLoad()\r\n        \r\n        centerLabel.text = String(format: NSLocalizedString(\"current.app.name.version\", comment: \"Center display of app name and current version\"),\r\n            Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as! String,\r\n            Bundle.main.infoDictionary?[kCFBundleVersionKey as String] as! String)\r\n        \r\n        startTutorial()\r\n    }\r\n    \r\n    /// Launched to start tutorial\r\n    func startTutorial() {\r\n        let alertController = UIAlertController(\r\n            title: NSLocalizedString(\"tutorial.alert.title\", comment: \"Title of main tutorial dialog\"),\r\n            message: NSLocalizedString(\"tutorial.alert.message\", comment: \"Message of main tutorial dialog\"),\r\n            preferredStyle: .alert\r\n        )\r\n        \r\n        alertController.addAction(UIAlertAction(title: NSLocalizedString(\"tutorial.alert.accept\", comment: \"OK button of main tutorial dialog\"), style: .default) { _ in\r\n            self.firstLabel.text = .localizedStringWithFormat(NSLocalizedString(\"one.corner.label.1\", comment: \"First corner of main screen translating number 1\"), 1)\r\n            self.secondLabel.text = .localizedStringWithFormat(NSLocalizedString(\"two.corner.label.2\", comment: \"Second corner of main screen translating number 2\"), 2)\r\n            self.thirdLabel.text = .localizedStringWithFormat(NSLocalizedString(\"three.corner.label.3\", comment: \"Third corner of main screen translating number 3\"), 3)\r\n            self.fourthLabel.text = .localizedStringWithFormat(NSLocalizedString(\"four.corner.label.4\", comment: \"Fourth corner of main screen translating number 4\"), 4)\r\n        })\r\n        \r\n        present(alertController, animated: true)\r\n    }\r\n    \r\n}</pre>\n<p><em>After:</em></p>\n<pre class=\"lang:swift decode:true\">class ViewController2: UIViewController {\r\n    \r\n    ...\r\n    \r\n    override func viewDidLoad() {\r\n        super.viewDidLoad()\r\n        \r\n        centerLabel.text = .localizedFormat(.currentAppNameVersion,\r\n            Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as! String,\r\n            Bundle.main.infoDictionary?[kCFBundleVersionKey as String] as! String\r\n        )\r\n        \r\n        startTutorial()\r\n    }\r\n    \r\n    /// Launched to start tutorial\r\n    func startTutorial() {\r\n        let alertController = UIAlertController(\r\n            title: .localized(.tutorialAlertTitle),\r\n            message: .localized(.tutorialAlertMessage),\r\n            preferredStyle: .alert\r\n        )\r\n        \r\n        alertController.addAction(UIAlertAction(title: .localized(.tutorialAlertAccept), style: .default) { _ in\r\n            self.firstLabel.text = .localizedLocale(.oneCornerLabel1, 1)\r\n            self.secondLabel.text = .localizedLocale(.twoCornerLabel2, 2)\r\n            self.thirdLabel.text = .localizedLocale(.threeCornerLabel3, 3)\r\n            self.fourthLabel.text = .localizedLocale(.fourCornerLabel4, 4)\r\n        })\r\n        \r\n        present(alertController, animated: true)\r\n    }\r\n    \r\n}</pre>\n<p><em>Localizable.swift (micro-library):</em></p>\n<pre class=\"lang:swift decode:true\">struct Localizable {\r\n    fileprivate let contents: String\r\n    \r\n    init(_ contents: String) {\r\n        self.contents = contents\r\n    }\r\n}\r\n\r\nextension String {\r\n    \r\n    /// A string initialized by using format as a template into which values in argList are substituted according the current locale information.\r\n    private static var vaListHandler: (_ key: String, _ arguments: CVaListPointer, _ locale: Locale?) -&gt; String {\r\n        // https://stackoverflow.com/questions/42428504/swift-3-issue-with-cvararg-being-passed-multiple-times\r\n        return { return NSString(format: $0, locale: $2, arguments: $1) as String }\r\n    }\r\n\r\n    /// Returns a localized string.\r\n    static func localized(_ key: Localizable) -&gt; String {\r\n        return key.contents\r\n    }\r\n\r\n    /// Returns a string created by using a given format string as a template into which the remaining argument values are substituted.\r\n    /// Equivalent to `String(format: value)`.\r\n    static func localizedFormat(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return withVaList(arguments) { vaListHandler(key.contents, $0, nil) } as String\r\n    }\r\n\r\n    /// Returns a string created by using a given format string as a template into which the\r\n    /// remaining argument values are substituted according to the user‚Äôs default locale.\r\n    /// Equivalent to `String.localizedStringWithFormat(value, arguments)`.\r\n    static func localizedLocale(_ key: Localizable, _ arguments: CVarArg...) -&gt; String {\r\n        return withVaList(arguments) { vaListHandler(key.contents, $0, .current) } as String\r\n    }\r\n}</pre>\n<p><em>AppLocalizable.swift:</em></p>\n<pre class=\"lang:swift decode:true\">// MARK: - Main Scene\r\nextension Localizable {\r\n    static let currentAppNameVersion = Localizable(NSLocalizedString(\"current.app.name.version\", comment: \"Center display of app name and current version\"))\r\n    static let oneCornerLabel1 = Localizable(NSLocalizedString(\"one.corner.label.1\", comment: \"First corner of main screen translating number 1\"))\r\n    static let twoCornerLabel2 = Localizable(NSLocalizedString(\"two.corner.label.2\", comment: \"Second corner of main screen translating number 2\"))\r\n    static let threeCornerLabel3 = Localizable(NSLocalizedString(\"three.corner.label.3\", comment: \"Third corner of main screen translating number 3\"))\r\n    static let fourCornerLabel4 = Localizable(NSLocalizedString(\"four.corner.label.4\", comment: \"Fourth corner of main screen translating number 4\"))\r\n}\r\n\r\n// MARK: - Tutorial\r\nextension Localizable {\r\n    static let tutorialAlertTitle = Localizable(NSLocalizedString(\"tutorial.alert.title\", comment: \"Tutorial intro and getting started\"))\r\n    static let tutorialAlertMessage = Localizable(NSLocalizedString(\"tutorial.alert.message\", comment: \"Tutorial submitting feedback and contact\"))\r\n    static let tutorialAlertAccept = Localizable(NSLocalizedString(\"tutorial.alert.accept\", comment: \"Tutorial done and dismiss\"))\r\n}\r\n</pre>\n<p>You can <a href=\"https://github.com/basememara/SwiftyLocalizable\" target=\"_blank\" rel=\"noopener\">download the working sample</a> and give it a try.</p>\n<p><em><strong>Happy Coding!!</strong></em></p>\n"
        },
        {
            "id": 41373,
            "title": "Protocol-Oriented Themes for iOS Apps",
            "slug": "protocol-oriented-themes-for-ios-apps",
            "type": "post",
            "excerpt": "Themes are usually downplayed as an after-thought instead of being an integral part of the development process. How many times have you inherited a codebase where the design team wants to tweak it, or business wants you to clone the app with a whole different theme. In this post, I'm going to show you the native way of theming an iOS app as intended by Apple that is often overlooked.",
            "created": "2018-09-29T17:12:15",
            "modified": "2019-03-18T02:25:53",
            "comment_count": 2,
            "link": "https://basememara.com/protocol-oriented-themes-for-ios-apps/",
            "author": 2,
            "featured_media": 41397,
            "categories": [
                55
            ],
            "tags": [
                53,
                62,
                81
            ],
            "content": "<p>Themes are usually downplayed as an after-thought instead of being an integral part of the development process. How many times have you inherited a codebase where the design team wants to tweak it, or business wants you to clone the app with a whole different theme.¬†Then you look at the code&#8230;</p>\n<p><em>Color and font changes are sprinkled all over storyboards and views!!</em></p>\n<p>Ok you wish they had a bit more foresight when they were making the app the first time, but then they wouldn&#8217;t have reached out to you now right? In this post, I&#8217;m going to show you the native way of theming an iOS app as intended by Apple. It&#8217;s often overlooked, well because&#8230;</p>\n<h2>UIAppearance Sucks</h2>\n<p>I&#8217;m sure most of you have toyed with <a href=\"https://developer.apple.com/documentation/uikit/uiappearance\" target=\"_blank\" rel=\"noopener noreferrer\"><em>UIAppearance</em></a> and quickly gave up on it because of its limitations, especially if you&#8217;ve been spoiled with CSS stylesheets for web development or theme resources for Android apps. Apple&#8217;s way of theming is quite awkward, but it&#8217;s what we got and I urge you not to roll out your own or use yet another dependency.</p>\n<p>In a nutshell, <code>UIAppearance</code> allows you to style <em>UIKit</em> controls globally using a proxy, or a class that stands in as a placeholder which applies itself to the control when it gets added to the window hierarchy. For example, you can globally change labels to red text like this:</p>\n<pre class=\"lang:swift decode:true\">UILabel.appearance().textColor = .red</pre>\n<p>It&#8217;s like a static function that gets applied to all future instances. Though, it&#8217;s like a sledge hammer for a nail because it applies to <em>ALL</em> labels in the app, even in places you didn&#8217;t even know labels existed! This is where most people give up on <code>UIAppearance</code>.</p>\n<h2>UIAppearance Sucks&#8230; Well Kinda&#8230;</h2>\n<p>Apple&#8217;s answer to styles and themes is for you to subclass your <em>UIKit</em> controls and use <code>UIAppearance</code> on those custom controls like this:</p>\n<pre class=\"lang:swift decode:true\">AppLabel.appearance().textColor = .red</pre>\n<p>That&#8217;s the awkward part, Apple wants you to use object-oriented programming to theme your apps. I don&#8217;t think they understood that a CSS-<em>class</em> isn&#8217;t really a <em>class</em> üôÑ.</p>\n<p>You can take it one step further though:</p>\n<pre class=\"lang:swift decode:true\">AppLabel.appearance(whenContainedInInstancesOf: [MyCustomView.self]).textColor = .red</pre>\n<p>This will change the appearance of all <em>AppLabel&#8217;s</em>¬†only contained in <em>MyCustomView&#8217;s</em>. So that&#8217;s your other option &#8211; to change your UI hierarchy to accommodate styling ü§¶.¬†Why couldn&#8217;t they just add a new space-delimited string property called styles that gets realized by its children??</p>\n<p>Anyways, surprisingly things become really powerful when you start feeding <code>whenContainedInInstancesOf</code> an array of classes, which defines the hierarchy chain of the control. The specificity let&#8217;s you zero in on controls.</p>\n<pre class=\"lang:swift decode:true\">AppLabel.appearance(whenContainedInInstancesOf: [MyViewController.self]).textColor = .blue\nAppLabel.appearance(whenContainedInInstancesOf: [MyCustomView.self]).textColor = .red\nAppLabel.appearance(whenContainedInInstancesOf: [MyCustomView.self, MyViewController.self]).textColor = .yellow</pre>\n<p>Another Apple awkwardness is that the outer most parent wins (unlike CSS and the rest of the world). So in the above example, <code>[MyViewController.self]</code> wins over <code>[MyCustomView.self]</code>, even though <code>MyCustomView</code> is the closest parent.</p>\n<p>The way it works is the selector starts from top-to-bottom of the hierarchy, which means when it first hits¬†<code>MyViewController</code>¬†it stops. The label will be blue, not red, even if it&#8217;s contained in a <code>MyCustomView</code>. Fortunately though, the longer your array is (the more specific it is), the higher priority it is. In this case, the labels in <code>MyCustomView</code>¬†will be yellow if it is on the <code>MyViewController</code>¬†screen.</p>\n<p>Once you understand and toy around with these quirks, it becomes a full-fledged styling framework!</p>\n<h2>Styleable Controls</h2>\n<p>First thing we must do is subclass all the controls we want to style in our app. Not the best use of object-oriented programming, but it&#8217;s native theming (<em>see rant above</em>). Here&#8217;s what I got:</p>\n<p><em>AppLabel.swift:</em></p>\n<pre class=\"lang:swift decode:true\">class AppLabel: UILabel {\n    \n}\n\nclass AppHeadline: UILabel {\n    \n}\n\nclass AppSubhead: UILabel {\n    \n}\n\nclass AppFootnote: UILabel {\n    \n}</pre>\n<p><em>AppButton.swift:</em></p>\n<pre class=\"lang:swift decode:true\">class AppButton: UIButton {\n    \n}\n\nclass AppDangerButton: UIButton {\n    \n}</pre>\n<p><em>AppSwitch.swift:</em></p>\n<pre class=\"lang:swift decode:true \">class AppSwitch: UISwitch {\n    \n}</pre>\n<p><em>AppView.swift:</em></p>\n<pre class=\"lang:swift decode:true\">class AppView: UIView {\n    \n}\n\nclass AppSeparator: UIView {\n    \n}</pre>\n<p>In our storyboard, we will now use these custom classes:</p>\n<p><img src=\"http://basememara.com/wp-content/uploads/2018/09/UIKit-Xcode-Custom-Class-500x281.png\" alt=\"\" width=\"500\" height=\"281\" class=\"aligncenter size-medium wp-image-41382\" srcset=\"https://basememara.com/wp-content/uploads/2018/09/UIKit-Xcode-Custom-Class-500x281.png 500w, https://basememara.com/wp-content/uploads/2018/09/UIKit-Xcode-Custom-Class-768x432.png 768w, https://basememara.com/wp-content/uploads/2018/09/UIKit-Xcode-Custom-Class.png 854w\" sizes=\"(max-width: 500px) 100vw, 500px\" /></p>\n<p>However, we will not change colors in the storyboard.. leave them all on the defaults! Nor will we style and theme the custom controls in the <code>awakeFromNib()</code> event!</p>\n<p>Instead we will style our controls like this:</p>\n<pre class=\"lang:swift decode:true\">AppLabel.appearance().textColor = .red\nAppSubhead.appearance().textColor = .purple\nAppFootnote.appearance().textColor = .orange\n\nAppButton.appearance().setTitleColor(.green, for: .normal)\nAppButton.appearance().borderColor = .green\nAppButton.appearance().borderWidth = 1\nAppButton.appearance().cornerRadius = 3\n</pre>\n<p>This should take place in the <code>AppDelegate.willFinishLaunchingWithOptions</code> event so it can be ready before any controls are loaded into your app. You can call the <code>UIAppearance</code>¬†proxy later to change your styles, but it will only apply to newly added controls to the window. All existing controls need to be removed and added back to have the new styles take effect (yes more quirks, but I have a helper below I will mention).</p>\n<h2>The Theme Protocol</h2>\n<p>We need swappable themes for our app right? Even if you only have one theme, designing it in such a way will allow you to maintain the styles much more easily and add different themes later.</p>\n<p>Here&#8217;s a protocol for the themes we can use:</p>\n<pre class=\"lang:swift decode:true \">protocol Theme {\n    var tint: UIColor { get }\n    var secondaryTint: UIColor { get }\n    \n    var backgroundColor: UIColor { get }\n    var separatorColor: UIColor { get }\n    var selectionColor: UIColor { get }\n    \n    var labelColor: UIColor { get }\n    var secondaryLabelColor: UIColor { get }\n    var subtleLabelColor: UIColor { get }\n    \n    var barStyle: UIBarStyle { get }\n}</pre>\n<p>Then we can extend the protocol to change the appearance for controls using the above properties which themes will conform to. The extension can look something like:</p>\n<pre class=\"lang:swift decode:true\">extension Theme {\n    \n    func apply(for application: UIApplication) {\n        application.keyWindow?.tintColor = tint\n        \n        UITabBar.appearance().barStyle = barStyle\n        \n        UINavigationBar.appearance().barStyle = barStyle\n        UINavigationBar.appearance().tintColor = tint\n        UINavigationBar.appearance().titleTextAttributes = [\n            .foregroundColor: labelColor\n        ]\n        \n        if #available(iOS 11.0, *) {\n            UINavigationBar.appearance().largeTitleTextAttributes = [\n                .foregroundColor: labelColor\n            ]\n        }\n        \n        UICollectionView.appearance().backgroundColor = backgroundColor\n        UITableView.appearance().backgroundColor = backgroundColor\n        UITableView.appearance().separatorColor = separatorColor\n        UITableViewCell.appearance().backgroundColor = .clear\n        UITableViewCell.appearance().selectionColor = selectionColor\n        \n        UIView.appearance(whenContainedInInstancesOf: [UITableViewHeaderFooterView.self])\n            .backgroundColor = selectionColor\n        \n        UILabel.appearance(whenContainedInInstancesOf: [UITableViewHeaderFooterView.self])\n            .textColor = secondaryLabelColor\n        \n        AppLabel.appearance().textColor = labelColor\n        AppSubhead.appearance().textColor = secondaryLabelColor\n        AppFootnote.appearance().textColor = subtleLabelColor\n        \n        AppButton.appearance().borderColor = tint\n        AppButton.appearance().setTitleColor(tint, for: .normal)\n        AppButton.appearance().borderWidth = 1\n        AppButton.appearance().cornerRadius = 3\n        \n        AppDangerButton.appearance().borderWidth = 0\n        AppDangerButton.appearance().setTitleColor(labelColor, for: .normal)\n        AppDangerButton.appearance().backgroundColor = tint\n        \n        AppSwitch.appearance().tintColor = tint\n        \n        AppView.appearance().backgroundColor = backgroundColor\n        AppSeparator.appearance().backgroundColor = separatorColor\n        AppSeparator.appearance().alpha = 0.5\n    }\n}</pre>\n<p>And the themes that conform would only have to fill in the property values:</p>\n<pre class=\"lang:swift decode:true\">struct DarkTheme: Theme {\n    let tint: UIColor = .yellow\n    let secondaryTint: UIColor = .green\n    \n    let backgroundColor: UIColor = .black\n    let separatorColor: UIColor = .lightGray\n    let selectionColor: UIColor = .init(red: 38/255, green: 38/255, blue: 40/255, alpha: 1)\n    \n    let labelColor: UIColor = .white\n    let secondaryLabelColor: UIColor = .lightGray\n    let subtleLabelColor: UIColor = .darkGray\n    \n    let barStyle: UIBarStyle = .black\n}</pre>\n<p>Here&#8217;s what another theme would look like:</p>\n<pre class=\"lang:swift decode:true\">struct LightTheme: Theme {\n    let tint: UIColor = .blue\n    let secondaryTint: UIColor = .orange\n    \n    let backgroundColor: UIColor = .white\n    let separatorColor: UIColor = .lightGray\n    let selectionColor: UIColor = .init(red: 236/255, green: 236/255, blue: 236/255, alpha: 1)\n    \n    let labelColor: UIColor = .black\n    let secondaryLabelColor: UIColor = .darkGray\n    let subtleLabelColor: UIColor = .lightGray\n    \n    let barStyle: UIBarStyle = .default\n}</pre>\n<p>Finally you call the theme early in the app lifecycle:</p>\n<pre class=\"lang:swift decode:true \">@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    private let theme = DarkTheme()\n    \n    var window: UIWindow?\n\n    func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {\n        theme.apply(for: application)\n        return true\n    }\n}</pre>\n<p>There you have it &#8211; native, simple theming for your iOS app.. no dependency, magic, or singleton!</p>\n<h2>Extending Themes</h2>\n<p>What if one of your custom themes wants to add extra styling? Implementing the <code>func apply(for application: UIApplication)</code> on the theme will wipe out existing logic which is not what we want, so instead I can add a¬†<code>func extend()</code>¬†to the protocol and call it within the <code>apply(for:)</code>¬†extension:</p>\n<pre class=\"lang:swift decode:true \">protocol Theme {\n    ...\n    func apply(for application: UIApplication)\n    func extend()\n}\n\nextension Theme {\n    \n    func apply(for application: UIApplication) {\n        ...\n        extend()\n    }\n    \n    func extend() {\n        // Optionally extend theme\n    }\n}</pre>\n<p>You see how <code>apply(for:)</code>¬†calls <code>extend()</code>¬†right in the protocol extension? Now the themes that conform can simply put their extended styling logic in <code>extend()</code>:</p>\n<pre class=\"lang:swift decode:true \">struct LightTheme: Theme {\n    ...\n}\n\nextension LightTheme {\n    \n    func extend() {\n        let proxy1 = UIImageView.appearance(whenContainedInInstancesOf: [UITableViewCell.self])\n        proxy1.borderColor = separatorColor\n        proxy1.borderWidth = 1\n        \n        let proxy2 = UIImageView.appearance(whenContainedInInstancesOf: [UIButton.self, UITableViewCell.self])\n        proxy2.borderWidth = 0\n    }\n}</pre>\n<h2>Changing Themes</h2>\n<p>Another reason why most people abandon <code>UIAppearance</code>¬†is you can&#8217;t change styles for existing controls that are already loaded. Apple makes it clear in the <a href=\"https://developer.apple.com/documentation/uikit/uiappearance\" target=\"_blank\" rel=\"noopener noreferrer\">documentation</a>:</p>\n<blockquote><p>iOS applies appearance changes when a view enters a window, it doesn‚Äôt change the appearance of a view that‚Äôs already in a window. To change the appearance of a view that‚Äôs currently in a window, remove the view from the view hierarchy and then put it back.</p></blockquote>\n<p>It&#8217;s pretty ridiculous that every single control has to be removed and added again to realize the new styles. After changing <code>UIAppearance</code>¬†values, you have to traverse through the entire¬†<code>UIWindow</code>¬†hierarchy and remove/add ¬†controls:</p>\n<pre class=\"lang:swift decode:true \">UIApplication.shared.windows.forEach { window in\n    window.subviews.forEach { view in\n        view.removeFromSuperview()\n        window.addSubview(view)\n    }\n}\n</pre>\n<p>It makes my stomach turn, but I guess users shouldn&#8217;t be changing themes often &#8211; plus it&#8217;s still native theming right?</p>\n<p>Take it one step further and turn it into an extension:</p>\n<pre class=\"lang:swift decode:true\">public extension UIWindow {\n    \n    /// Unload all views and add back.\n    /// Useful for applying `UIAppearance` changes to existing views.\n    func reload() {\n        subviews.forEach { view in\n            view.removeFromSuperview()\n            addSubview(view)\n        }\n    }\n}\n\npublic extension Array where Element == UIWindow {\n    \n    /// Unload all views for each `UIWindow` and add back.\n    /// Useful for applying `UIAppearance` changes to existing views.\n    func reload() {\n        forEach { $0.reload() }\n    }\n}</pre>\n<p>Now in your original <code>Theme</code>¬†protocol, you can abstract it away:</p>\n<pre class=\"lang:swift decode:true\">protocol Theme {\n    ...\n}\n\nextension Theme {\n    \n    func apply(for application: UIApplication) {\n        ...\n        \n        // Ensure existing views render with new theme\n        application.windows.reload()\n    }</pre>\n<p>Note that the first time the theme gets applied in <code>AppDelegate.willFinishLaunchingWithOptions</code>, the ¬†<code>window</code>¬†object won&#8217;t have any subviews in it so it will just be ignored. The <code>reload</code>¬†will only run if called after <code>AppDelegate.willFinishLaunchingWithOptions</code>.</p>\n<h2>Beyond Colors</h2>\n<p>So far I&#8217;ve only emphasized colors, but you can style fonts with <code>UIAppearance</code>, but I prefer to only use the built-in ones in storyboard because it respects dynamic font sizes. If your designer insists, you&#8217;ll want to support accessibility which is a whole other topic.</p>\n<p>But did you know you can use <code>UIAppearance</code>¬†on just about any property? You can even change text properties for all <code>UILabel</code>¬†controls!¬†Of course this would be obnoxious to do, but it&#8217;s possible:</p>\n<pre class=\"lang:swift decode:true \">UILabel.appearance().text = \"Hello World!\"</pre>\n<p>You could, however, add your own custom properties and set them via¬†<code>UIAppearance</code>¬†as well! Let&#8217;s take the selected highlight color for <code>UITableViewCell</code>. This is not a native property from <code>UIKit</code>¬†unfortunately, so you&#8217;d have to do something like this:</p>\n<pre class=\"lang:swift decode:true \">let selectedView = UIView()\nselectedView.backgroundColor = .lightGray\n\nmyTableViewCell.selectedBackgroundView = selectedView</pre>\n<p>You could take it one step further and turn it into an extension:</p>\n<pre class=\"lang:swift decode:true \">extension UITableViewCell {\n    \n    /// The color of the cell when it is selected.\n    var selectionColor: UIColor? {\n        get { return selectedBackgroundView?.backgroundColor }\n        set {\n            guard selectionStyle != .none else { return }\n            selectedBackgroundView = UIView().with {\n                $0.backgroundColor = newValue\n            }\n        }\n    }\n}</pre>\n<p>When you try to update this property via <code>UIAppearance</code>, you&#8217;ll notice it doesn&#8217;t do anything. To expose your custom properties to <code>UIAppearance</code>, you have to add the <code>dynamic</code>¬†keyword to the property to¬†force the <em>Swift</em> compiler to use an¬†<em>Objective-C</em> message that <code>UIAppearance</code> relies on:</p>\n<pre class=\"lang:swift decode:true \">extension UITableViewCell {\n    \n    /// The color of the cell when it is selected.\n    @objc dynamic var selectionColor: UIColor? {\n        get { return selectedBackgroundView?.backgroundColor }\n        set {\n            guard selectionStyle != .none else { return }\n            selectedBackgroundView = UIView().with {\n                $0.backgroundColor = newValue\n            }\n        }\n    }\n}</pre>\n<p>Now you can do this:</p>\n<pre class=\"lang:swift decode:true \">UITableViewCell.appearance().selectionColor = .init(red: 38/255, green: 38/255, blue: 40/255, alpha: 1)</pre>\n<p>At this point, we got everything we need.</p>\n<h2>Demo Time!</h2>\n<p>I put together a sample project with a segmented control to switch between themes:</p>\n<p><img src=\"http://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot-500x354.png\" alt=\"\" width=\"500\" height=\"354\" class=\"aligncenter size-medium wp-image-41397\" srcset=\"https://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot-500x354.png 500w, https://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot-768x544.png 768w, https://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot-1024x725.png 1024w\" sizes=\"(max-width: 500px) 100vw, 500px\" /></p>\n<p>The <code>Theme</code>¬†protocol that does the heavy lifting looks like this:</p>\n<pre class=\"lang:swift decode:true \">protocol Theme {\n    var tint: UIColor { get }\n    var secondaryTint: UIColor { get }\n    \n    var backgroundColor: UIColor { get }\n    var separatorColor: UIColor { get }\n    var selectionColor: UIColor { get }\n    \n    var labelColor: UIColor { get }\n    var secondaryLabelColor: UIColor { get }\n    var subtleLabelColor: UIColor { get }\n    \n    var barStyle: UIBarStyle { get }\n    \n    func apply(for application: UIApplication)\n    func extend()\n}\n\nextension Theme {\n    \n    func apply(for application: UIApplication) {\n        application.keyWindow?.tintColor = tint\n        \n        UITabBar.appearance().with {\n            $0.barStyle = barStyle\n            $0.tintColor = tint\n        }\n        \n        UINavigationBar.appearance().with {\n            $0.barStyle = barStyle\n            $0.tintColor = tint\n            $0.titleTextAttributes = [\n                .foregroundColor: labelColor\n            ]\n            \n            if #available(iOS 11.0, *) {\n                $0.largeTitleTextAttributes = [\n                    .foregroundColor: labelColor\n                ]\n            }\n        }\n        \n        UICollectionView.appearance().backgroundColor = backgroundColor\n        \n        UITableView.appearance().with {\n            $0.backgroundColor = backgroundColor\n            $0.separatorColor = separatorColor\n        }\n        \n        UITableViewCell.appearance().with {\n            $0.backgroundColor = .clear\n            $0.selectionColor = selectionColor\n        }\n        \n        UIView.appearance(whenContainedInInstancesOf: [UITableViewHeaderFooterView.self])\n            .backgroundColor = selectionColor\n        \n        UILabel.appearance(whenContainedInInstancesOf: [UITableViewHeaderFooterView.self])\n            .textColor = secondaryLabelColor\n        \n        AppLabel.appearance().textColor = labelColor\n        AppHeadline.appearance().textColor = secondaryTint\n        AppSubhead.appearance().textColor = secondaryLabelColor\n        AppFootnote.appearance().textColor = subtleLabelColor\n        \n        AppButton.appearance().with {\n            $0.setTitleColor(tint, for: .normal)\n            $0.borderColor = tint\n            $0.borderWidth = 1\n            $0.cornerRadius = 3\n        }\n        \n        AppDangerButton.appearance().with {\n            $0.setTitleColor(backgroundColor, for: .normal)\n            $0.backgroundColor = tint\n            $0.cornerRadius = 3\n        }\n        \n        AppSwitch.appearance().with {\n            $0.tintColor = tint\n            $0.onTintColor = tint\n        }\n        \n        AppStepper.appearance().tintColor = tint\n        \n        AppSlider.appearance().tintColor = tint\n        \n        AppSegmentedControl.appearance().tintColor = tint\n        \n        AppView.appearance().backgroundColor = backgroundColor\n        \n        AppSeparator.appearance().with {\n            $0.backgroundColor = separatorColor\n            $0.alpha = 0.5\n        }\n        \n        AppView.appearance(whenContainedInInstancesOf: [AppView.self]).with {\n            $0.backgroundColor = selectionColor\n            $0.cornerRadius = 10\n        }\n        \n        // Style differently when inside a special container\n        \n        AppLabel.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).textColor = subtleLabelColor\n        AppHeadline.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).textColor = secondaryLabelColor\n        AppSubhead.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).textColor = secondaryTint\n        AppFootnote.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).textColor = labelColor\n        \n        AppButton.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).with {\n            $0.setTitleColor(labelColor, for: .normal)\n            $0.borderColor = labelColor\n        }\n        \n        AppDangerButton.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).with {\n            $0.setTitleColor(subtleLabelColor, for: .normal)\n            $0.backgroundColor = labelColor\n        }\n        \n        AppSwitch.appearance(whenContainedInInstancesOf: [AppView.self, AppView.self]).with {\n            $0.tintColor = secondaryTint\n            $0.onTintColor = secondaryTint\n        }\n        \n        extend()\n        \n        // Ensure existing views render with new theme\n        // https://developer.apple.com/documentation/uikit/uiappearance\n        application.windows.reload()\n    }\n    \n    func extend() {\n        // Optionally extend theme\n    }\n}</pre>\n<p>Then you can add as many themes as you want:</p>\n<pre class=\"lang:swift decode:true\">struct OceanTheme: Theme {\n    let tint: UIColor = .blue\n    let secondaryTint: UIColor = .orange\n    \n    let backgroundColor: UIColor = .cyan\n    let separatorColor: UIColor = .lightGray\n    let selectionColor: UIColor = .init(red: 38/255, green: 38/255, blue: 40/255, alpha: 1)\n    \n    let labelColor: UIColor = .magenta\n    let secondaryLabelColor: UIColor = .lightGray\n    let subtleLabelColor: UIColor = .darkGray\n    \n    let barStyle: UIBarStyle = .default\n}</pre>\n<p>Finally in my segmented control change event, I can simply change themes like this:</p>\n<pre class=\"lang:swift decode:true \">@IBAction func themeSegmentedControlChanged(_ sender: UISegmentedControl) {\n    let theme: Theme\n        \n    switch sender.selectedSegmentIndex {\n    case 1: theme = LightTheme()\n    case 2: theme = OceanTheme()\n    default: theme = DarkTheme()\n    }\n        \n    theme.apply(for: UIApplication.shared)\n}</pre>\n<p>The complete source code can be¬†<a href=\"https://github.com/basememara/ThemeKit\" target=\"_blank\" rel=\"noopener noreferrer\">downloaded and run here</a>.</p>\n<h2>Conclusion</h2>\n<p><code>UIAppearance</code>¬†has been around since iOS 5, but it is often overlooked and underestimated. Apple uses this framework to style its own apps, such as <em>Find Friends</em> and many other apps. Sticking with native functionality is always a good idea and hopefully I&#8217;ve given you a newfound appreciation for the built-in theming framework.</p>\n<p>To learn more about <code>UIAppearance</code>, check out these resources:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2011/114/\" target=\"_blank\" rel=\"noopener noreferrer\">WWDC 2011:¬†Customizing the Appearance of UIKit Controls</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2012/216/\" target=\"_blank\" rel=\"noopener noreferrer\">WWDC 2012:¬†Advanced Appearance Customization on iOS</a></li>\n<li><a href=\"https://spin.atomicobject.com/2017/08/16/uiappearance-container-hierarchies/\" target=\"_blank\" rel=\"noopener noreferrer\">Understanding UIAppearance Container Hierarchies</a></li>\n</ul>\n<p><em><strong>Happy Coding!!</strong></em></p>\n<hr />\r\n<h2 style=\"text-align: center;\">FREE Masterclass Webinar: Creating Cross-Platform Swift Frameworks for iOS, watchOS, &amp; tvOS!</h2>\r\n<p>An essential part of creating scalable apps is code organization. Watch my updated \"Creating Cross-Platform Swift Frameworks\" webinar; it will change the way you build iOS apps! <a href=\"https://iosmentor.io/webinars/swift-frameworks/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://basememara.com/wp-content/uploads/2018/04/swift-framework-webinar.png\" alt=\"\" width=\"406\" height=\"257\" class=\"aligncenter size-full wp-image-41351\" /></a></p>\n"
        }
    ],
    "authors": [
        {
            "id": 2,
            "name": "Basem Emara",
            "link": "https://basememara.com",
            "avatar": "https://secure.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=96&d=mm&r=g",
            "description": "Basem is a mobile and software IT professional with over 12 years of experience as an architect, developer, and consultant for dozens of projects that span over various industries for Fortune 500 enterprises, government agencies, and startups. In 2014, Basem brought his vast knowledge and experiences to Swift and helped pioneer the language to build scalable enterprise iOS &amp; watchOS apps, later providing mentorship courses at <a href=\"https://iosmentor.io\">https://iosmentor.io</a>.",
            "created": "2015-02-02T03:39:52",
            "modified": "2018-10-06T14:43:53"
        }
    ],
    "media": [
        {
            "id": 20745,
            "link": "https://basememara.com/wp-content/uploads/2017/07/localization.jpg",
            "width": 300,
            "height": 284,
            "thumbnail_link": "https://basememara.com/wp-content/uploads/2017/07/localization.jpg",
            "thumbnail_width": 300,
            "thumbnail_height": 284
        },
        {
            "id": 41397,
            "link": "https://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot.png",
            "width": 2194,
            "height": 1554,
            "thumbnail_link": "https://basememara.com/wp-content/uploads/2018/09/Theme-Screenshot-500x354.png",
            "thumbnail_width": 500,
            "thumbnail_height": 354
        }
    ],
    "categories": [
        {
            "id": 55,
            "parent": 0,
            "name": "Swift",
            "slug": "swift",
            "taxonomy": "category",
            "count": 29
        }
    ],
    "tags": [
        {
            "id": 77,
            "parent": 0,
            "name": "localization",
            "slug": "localization",
            "taxonomy": "post_tag",
            "count": 1
        },
        {
            "id": 50,
            "parent": 0,
            "name": "swift",
            "slug": "swift",
            "taxonomy": "post_tag",
            "count": 37
        },
        {
            "id": 47,
            "parent": 0,
            "name": "xcode",
            "slug": "xcode",
            "taxonomy": "post_tag",
            "count": 18
        },
        {
            "id": 53,
            "parent": 0,
            "name": "ios",
            "slug": "ios",
            "taxonomy": "post_tag",
            "count": 19
        },
        {
            "id": 62,
            "parent": 0,
            "name": "protocol-oriented-programming",
            "slug": "protocol-oriented-programming",
            "taxonomy": "post_tag",
            "count": 9
        },
        {
            "id": 81,
            "parent": 0,
            "name": "uikit",
            "slug": "uikit",
            "taxonomy": "post_tag",
            "count": 1
        }
    ]
}
